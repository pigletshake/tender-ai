<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>步骤4 - 写标书</title>
  <link rel="stylesheet" href="../assets/css/shared.css">
  <style>
    #markdownPreview {
      line-height: 1.6;
    }
    #markdownPreview h1 {
      font-size: 2em;
      font-weight: bold;
      margin: 1em 0 0.5em 0;
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 0.5em;
    }
    #markdownPreview h2 {
      font-size: 1.5em;
      font-weight: bold;
      margin: 1em 0 0.5em 0;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 0.3em;
    }
    #markdownPreview h3 {
      font-size: 1.25em;
      font-weight: bold;
      margin: 0.8em 0 0.4em 0;
    }
    #markdownPreview p {
      margin: 0.5em 0;
    }
    #markdownPreview ul, #markdownPreview ol {
      margin: 0.5em 0;
      padding-left: 2em;
    }
    #markdownPreview li {
      margin: 0.3em 0;
    }
    #markdownPreview code {
      background-color: #f3f4f6;
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
    }
    #markdownPreview pre {
      background-color: #f3f4f6;
      padding: 1em;
      border-radius: 8px;
      overflow-x: auto;
      margin: 1em 0;
    }
    #markdownPreview pre code {
      background-color: transparent;
      padding: 0;
    }
    #markdownPreview blockquote {
      border-left: 4px solid #3b82f6;
      padding-left: 1em;
      margin: 1em 0;
      color: #6b7280;
    }
    #markdownPreview table {
      border-collapse: collapse;
      width: 100%;
      margin: 1em 0;
    }
    #markdownPreview table th,
    #markdownPreview table td {
      border: 1px solid #e5e7eb;
      padding: 0.5em;
      text-align: left;
    }
    #markdownPreview table th {
      background-color: #f9fafb;
      font-weight: bold;
    }
    /* 吸底工具栏样式 */
    .bottom-toolbar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: white;
      border-top: 1px solid #e5e7eb;
      padding: 1rem;
      box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      display: flex;
      justify-content: center;
    }
    .bottom-toolbar .toolbar-content {
      max-width: 1200px;
      width: 100%;
      display: flex;
      gap: 0.5rem;
      justify-content: center;
    }
    /* 给内容区域添加底部padding，避免被工具栏遮挡 */
    body .container {
      padding-bottom: 80px !important;
    }
  </style>
</head>
<body>
  <div class="container">
    <a href="../index.html" class="text-blue-600 underline text-sm">返回主页</a>
    <h1 class="text-2xl font-bold mb-4">步骤4：写标书</h1>

    <div class="card space-y-4">
      <div>
        <label class="block text-sm font-medium mb-2">招标需求：</label>
        <textarea id="parseResult" class="input" rows="4" placeholder="暂无数据，需先完成步骤1"></textarea>
      </div>

      <div>
        <label class="block text-sm font-medium mb-2">标书大纲：</label>
        <textarea id="outlineResult" class="input" rows="6" placeholder="暂无数据，需先完成步骤2"></textarea>
      </div>

      <div>
        <label class="block text-sm font-medium mb-2">公司资料：</label>
        <textarea id="companyResult" class="input" rows="6" placeholder="暂无数据，需先完成步骤3"></textarea>
      </div>

      <div>
        <label class="block text-sm font-medium mb-2">说明（可选）</label>
        <textarea id="userReq" class="input" rows="4" placeholder="请输入用户需求或补充说明"></textarea>
      </div>

      <div class="flex space-x-2">
        <button id="runBtn" class="btn btn-primary">提交</button>
      </div>

      <div id="resultContainer">
        <div class="flex items-center justify-between mb-2">
          <label class="block text-sm font-medium"><h2>输出标书内容：</h2></label>
        </div>
        <div id="previewMode">
          <div id="markdownPreview" class="input p-4" style="min-height: 400px; overflow-y: auto;"></div>
        </div>
        <div id="editMode" class="hidden">
          <!-- 动态生成的文本框将插入这里 -->
        </div>
      </div>
    </div>
  </div>
  
  <!-- 吸底工具栏 -->
  <div class="bottom-toolbar">
    <div class="toolbar-content">
      <button id="editBtn" class="btn btn-secondary text-sm">编辑模式</button>
      <button id="saveBtn" class="btn btn-secondary">保存修改并下一步</button>
      <button id="nextBtn" class="btn">直接下一步</button>
    </div>
  </div>

  <script src="../assets/js/store.js"></script>
  <script src="../assets/js/utils.js"></script>
  <script src="../assets/js/ui.js"></script>
  <script src="../assets/js/api.js"></script>
  <script src="../assets/js/batchSubmit.js"></script>
  <!-- Markdown 渲染库 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
  <script>
    const parseResult = document.getElementById('parseResult');
    const outlineResult = document.getElementById('outlineResult');
    const companyResult = document.getElementById('companyResult');
    const userReq = document.getElementById('userReq');
    const runBtn = document.getElementById('runBtn');
    const editBtn = document.getElementById('editBtn');
    const saveBtn = document.getElementById('saveBtn');
    const nextBtn = document.getElementById('nextBtn');
    const resultContainer = document.getElementById('resultContainer');
    const previewMode = document.getElementById('previewMode');
    const editMode = document.getElementById('editMode');
    const markdownPreview = document.getElementById('markdownPreview');
    
    let currentResultData = null; // 保存当前结果数据，用于在预览和编辑模式间切换

    // 过滤掉 <think></think> 标签及其内容
    function filterRedactedReasoning(text) {
      if (!text || typeof text !== 'string') return text;
      
      let filtered = text;
      
      // 匹配 <think>...</think> 标签（包括换行和所有字符）
      // 使用非贪婪匹配，匹配标签内的所有内容（包括换行）
      // 优先匹配 <think>...</think> 这种格式
      filtered = filtered.replace(/<think>[\s\S]*?<\/redacted_reasoning>/gi, '');
      
      // 也匹配 <think>...</think> 标签（兼容不同的结束标签）
      filtered = filtered.replace(/<think>[\s\S]*?<\/think>/gi, '');
      
      // 移除标签后可能留下的多余空白行（3个或更多连续换行）
      filtered = filtered.replace(/\n{3,}/g, '\n\n');
      
      // 移除开头和结尾的空白
      return filtered.trim();
    }

    // 渲染 Markdown 预览
    function renderMarkdownPreview(result) {
      let markdown = '';
      
      try {
        let parsedResult = result || currentResultData;
        if (!parsedResult) {
          console.warn('renderMarkdownPreview: 没有数据可渲染');
          return;
        }
        
        if (typeof parsedResult === 'string') {
          try {
            parsedResult = JSON.parse(parsedResult);
          } catch (e) {
            // 普通文本，直接渲染
            if (marked) {
              markdownPreview.innerHTML = marked.parse(parsedResult);
            } else {
              markdownPreview.textContent = parsedResult;
            }
            return;
          }
        }
        
        // 检查是否是包含 content 数组的结构
        let contentArray = null;
        if (parsedResult && parsedResult.data && parsedResult.data.outputs && parsedResult.data.outputs.content && Array.isArray(parsedResult.data.outputs.content)) {
          contentArray = parsedResult.data.outputs.content;
        } else if (parsedResult && parsedResult.content && Array.isArray(parsedResult.content)) {
          contentArray = parsedResult.content;
        }
        
        if (contentArray && contentArray.length > 0) {
          // 数组格式：合并所有章节的 Markdown
          console.log(`renderMarkdownPreview: 渲染 ${contentArray.length} 个章节`);
          contentArray.forEach((item, index) => {
            //markdown += `## ${item.title || `章节 ${index + 1}`}\n\n`;
            // 过滤掉 <think> 标签
            const filteredContent = filterRedactedReasoning(item.content || '');
            markdown += filteredContent;
            markdown += '\n\n';
          });
        } else {
          // 单个结果
          markdown = filterRedactedReasoning(Utils.getResultContent(parsedResult));
        }
        
        // 渲染 Markdown
        if (marked) {
          markdownPreview.innerHTML = marked.parse(markdown);
        } else {
          markdownPreview.textContent = markdown;
        }
        
        console.log(`renderMarkdownPreview: 渲染完成，Markdown 长度: ${markdown.length}`);
      } catch (e) {
        console.error('渲染预览失败:', e, result);
        markdownPreview.textContent = Utils.getResultContent(result || currentResultData);
      }
    }

    // 渲染编辑模式（支持数组格式）
    function renderEditMode(result) {
      // 清空编辑容器
      editMode.innerHTML = '';
      
      try {
        // 尝试解析为 JSON
        let parsedResult = result || currentResultData;
        if (!parsedResult) return;
        
        if (typeof parsedResult === 'string') {
          try {
            parsedResult = JSON.parse(parsedResult);
          } catch (e) {
            // 不是 JSON，当作普通文本处理
            const textarea = document.createElement('textarea');
            textarea.className = 'input';
            textarea.rows = 14;
            textarea.id = 'resultArea';
            textarea.placeholder = '结果将显示在此';
            // 过滤掉 <think> 标签
            textarea.value = filterRedactedReasoning(parsedResult);
            editMode.appendChild(textarea);
            return;
          }
        }
        
        // 检查是否是包含 content 数组的结构（从 API 返回的完整结构）
        if (parsedResult && parsedResult.data && parsedResult.data.outputs && parsedResult.data.outputs.content && Array.isArray(parsedResult.data.outputs.content)) {
          // 数组格式：为每个元素创建文本框
          parsedResult.data.outputs.content.forEach((item, index) => {
            const div = document.createElement('div');
            div.className = 'mb-4 p-4 border border-gray-200 rounded-lg';
            
            // 创建头部容器（序号、勾选框、标题、重新生成按钮）
            const header = document.createElement('div');
            header.className = 'flex items-center gap-3 mb-2';
            
            // 序号
            const number = document.createElement('span');
            number.className = 'flex items-center justify-center w-6 h-6 rounded-full bg-blue-500 text-white text-sm font-semibold';
            number.textContent = index + 1;
            
            // 勾选框
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'w-4 h-4 text-blue-600 rounded focus:ring-blue-500';
            checkbox.checked = true;
            checkbox.dataset.itemId = item.id || index;
            
            // 标题
            const label = document.createElement('label');
            label.className = 'text-sm font-medium flex-1';
            label.textContent = item.title || `内容 ${index + 1}`;
            
            // 重新生成按钮
            const regenerateBtn = document.createElement('button');
            regenerateBtn.type = 'button';
            regenerateBtn.className = 'btn btn-secondary text-xs px-2 py-1';
            regenerateBtn.textContent = '重新生成';
            regenerateBtn.dataset.chapterIndex = index;
            regenerateBtn.onclick = () => regenerateSingleChapter(index);
            
            header.appendChild(number);
            header.appendChild(checkbox);
            header.appendChild(label);
            header.appendChild(regenerateBtn);
            
            // 文本框
            const textarea = document.createElement('textarea');
            textarea.className = 'input';
            textarea.rows = 10;
            textarea.dataset.itemId = item.id || index;
            textarea.dataset.chapterIndex = index;
            // 过滤掉 <think> 标签
            textarea.value = filterRedactedReasoning(item.content || '');
            
            div.appendChild(header);
            div.appendChild(textarea);
            editMode.appendChild(div);
          });
        } else if (parsedResult && parsedResult.content && Array.isArray(parsedResult.content)) {
          // 直接是 content 数组（callDifyWorkflow 返回 outputs）
          parsedResult.content.forEach((item, index) => {
            const div = document.createElement('div');
            div.className = 'mb-4 p-4 border border-gray-200 rounded-lg';
            
            // 创建头部容器（序号、勾选框、标题、重新生成按钮）
            const header = document.createElement('div');
            header.className = 'flex items-center gap-3 mb-2';
            
            // 序号
            const number = document.createElement('span');
            number.className = 'flex items-center justify-center w-6 h-6 rounded-full bg-blue-500 text-white text-sm font-semibold';
            number.textContent = index + 1;
            
            // 勾选框
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'w-4 h-4 text-blue-600 rounded focus:ring-blue-500';
            checkbox.checked = true;
            checkbox.dataset.itemId = item.id || index;
            
            // 标题
            const label = document.createElement('label');
            label.className = 'text-sm font-medium flex-1';
            label.textContent = item.title || `内容 ${index + 1}`;
            
            // 重新生成按钮
            const regenerateBtn = document.createElement('button');
            regenerateBtn.type = 'button';
            regenerateBtn.className = 'btn btn-secondary text-xs px-2 py-1';
            regenerateBtn.textContent = '重新生成';
            regenerateBtn.dataset.chapterIndex = index;
            regenerateBtn.onclick = () => regenerateSingleChapter(index);
            
            header.appendChild(number);
            header.appendChild(checkbox);
            header.appendChild(label);
            header.appendChild(regenerateBtn);
            
            // 文本框
            const textarea = document.createElement('textarea');
            textarea.className = 'input';
            textarea.rows = 10;
            textarea.dataset.itemId = item.id || index;
            textarea.dataset.chapterIndex = index;
            // 过滤掉 <think> 标签
            textarea.value = filterRedactedReasoning(item.content || '');
            
            div.appendChild(header);
            div.appendChild(textarea);
            editMode.appendChild(div);
          });
        } else {
          // 单个结果：创建单个文本框
          const textarea = document.createElement('textarea');
          textarea.className = 'input';
          textarea.rows = 14;
          textarea.id = 'resultArea';
          textarea.placeholder = '结果将显示在此';
          // 过滤掉 <think> 标签
          textarea.value = filterRedactedReasoning(Utils.getResultContent(parsedResult));
          editMode.appendChild(textarea);
        }
      } catch (e) {
        console.error('渲染编辑模式失败:', e);
        // 解析失败，当作普通文本处理
        const textarea = document.createElement('textarea');
        textarea.className = 'input';
        textarea.rows = 14;
        textarea.id = 'resultArea';
        textarea.placeholder = '结果将显示在此';
        // 过滤掉 <think> 标签
        textarea.value = filterRedactedReasoning(Utils.getResultContent(result || currentResultData));
        editMode.appendChild(textarea);
      }
    }
    
    // 统一的结果渲染函数
    function renderResult(result) {
      currentResultData = result;
      renderMarkdownPreview(result);
      renderEditMode(result);
    }

    // 重新生成单个章节
    async function regenerateSingleChapter(chapterIndex) {
      try {
        // 检查必要的输入
        if (!outlineResult.value.trim()) {
          UI.showError('标书大纲不能为空');
          return;
        }
        
        // 解析大纲，获取所有章节
        const batches = BatchSubmit.parseOutlineToBatches(outlineResult.value.trim());
        if (!batches || batches.length === 0) {
          UI.showError('无法解析标书大纲');
          return;
        }
        
        if (chapterIndex < 0 || chapterIndex >= batches.length) {
          UI.showError(`章节索引超出范围（有效范围：0-${batches.length - 1}）`);
          return;
        }
        
        // 获取要重新生成的章节信息
        const batch = batches[chapterIndex];
        
        // batch.content 包含该章节的完整大纲结构，例如：
        // # 一、投标函及投标承诺
        // ## （一）投标函
        // ## （二）投标承诺声明
        // 这个内容会传给后台，后台会根据这个大纲结构生成该章节的内容
        
        console.log(`[重新生成章节 ${chapterIndex + 1}] 章节标题: ${batch.title}`);
        console.log(`[重新生成章节 ${chapterIndex + 1}] 传入的大纲内容:`, batch.content);
        
        // 找到对应的按钮和文本框 - 使用更精确的选择器
        // 先尝试在当前可见的编辑模式下查找
        let regenerateBtn = editMode.querySelector(`button[data-chapter-index="${chapterIndex}"]`);
        let textarea = editMode.querySelector(`textarea[data-chapter-index="${chapterIndex}"]`);
        
        // 如果找不到，可能是因为 editMode 被隐藏了，使用 document 全局查找
        if (!textarea) {
          textarea = document.querySelector(`textarea[data-chapter-index="${chapterIndex}"]`);
          console.log(`[重新生成] 在 editMode 中未找到文本框，尝试全局查找，结果:`, textarea);
        }
        if (!regenerateBtn) {
          regenerateBtn = document.querySelector(`button[data-chapter-index="${chapterIndex}"]`);
          console.log(`[重新生成] 在 editMode 中未找到按钮，尝试全局查找，结果:`, regenerateBtn);
        }
        
        if (!textarea) {
          console.error(`[重新生成失败] 无法找到章节 ${chapterIndex + 1} 的文本框`);
          console.log(`[调试信息] editMode 中的所有 textarea:`, editMode.querySelectorAll('textarea'));
          console.log(`[调试信息] 所有 data-chapter-index:`, Array.from(editMode.querySelectorAll('[data-chapter-index]')).map(el => el.dataset.chapterIndex));
          UI.showError(`未找到章节 ${chapterIndex + 1} 的文本框，请确保已切换到编辑模式`);
          return;
        }
        
        console.log(`[重新生成] 找到文本框，章节索引: ${chapterIndex}, 元素:`, textarea);
        
        // 禁用按钮，显示加载状态
        if (regenerateBtn) {
          regenerateBtn.disabled = true;
          regenerateBtn.textContent = '生成中...';
        }
        textarea.disabled = true;
        textarea.value = `正在为章节"${batch.title}"生成内容，请稍候...`;
        
        const apiKey = API.DIFY_CONFIG.apiKeys.step4;
        
        // 构建输入参数
        // outline_content: 该章节的完整大纲结构（包括一级标题和所有子章节）
        // 后台工作流会解析这个大纲，并生成对应的章节内容
        const inputs = {
          outline_content: batch.content, // 例如: "# 一、投标函及投标承诺\n## （一）投标函\n## （二）投标承诺声明"
          company_data: companyResult.value.trim() || '',
        };
        
        if (parseResult.value.trim()) {
          inputs.previous_result = parseResult.value.trim();
        }
        
        if (userReq.value.trim()) {
          inputs[API.DIFY_CONFIG.inputKeys.userRequirementsKey || 'user_requirements'] = userReq.value.trim();
        }
        
        // 调用 API
        const response = await fetch(`${API.DIFY_CONFIG.baseURL}/workflows/run`, {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${apiKey}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            inputs,
            response_mode: 'blocking',
            user: API.DIFY_CONFIG.user,
          }),
        });
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData?.message || errorData?.data?.error || `API调用失败: ${response.status}`);
        }
        
        // 处理响应
        const data = await response.json();
        let finalOutputs = null;
        
        if (data.data && data.data.outputs) {
          finalOutputs = data.data.outputs;
        } else if (data.outputs) {
          finalOutputs = data.outputs;
        } else if (data.error) {
          throw new Error(data.error || '工作流执行失败');
        } else {
          throw new Error('无法解析 API 响应');
        }
        
        // 提取章节内容
        let chapterContent = '';
        
        if (finalOutputs && finalOutputs.content && Array.isArray(finalOutputs.content)) {
          // 数组格式：合并所有内容项
          const contentItems = finalOutputs.content;
          if (contentItems.length === 1) {
            chapterContent = contentItems[0].content || '';
          } else if (contentItems.length > 1) {
            chapterContent = contentItems.map(item => {
              const itemTitle = item.title || '';
              const itemContent = item.content || '';
              return itemTitle ? `## ${itemTitle}\n\n${itemContent}` : itemContent;
            }).join('\n\n');
          }
        } else if (finalOutputs && finalOutputs.text) {
          chapterContent = finalOutputs.text;
        } else {
          chapterContent = JSON.stringify(finalOutputs) || '';
        }
        
        // 过滤掉 <think> 标签
        chapterContent = filterRedactedReasoning(chapterContent);
        
        // 更新文本框内容（编辑模式下的文本框） - 这是最重要的，确保用户立即看到新内容
        if (textarea) {
          textarea.value = chapterContent;
          textarea.disabled = false;
          console.log(`[重新生成完成] 章节 ${chapterIndex + 1} 的新内容已写入文本框，长度: ${chapterContent.length}`);
          console.log(`[重新生成完成] 文本框当前值（前100字符）:`, textarea.value.substring(0, 100));
          
          // 强制触发 input 事件，确保任何监听器都能收到更新
          textarea.dispatchEvent(new Event('input', { bubbles: true }));
        } else {
          console.error(`[重新生成失败] 文本框不存在，无法写入内容`);
          UI.showError('无法找到文本框，内容更新失败');
          return;
        }
        
        // 更新 currentResultData 中对应章节的内容
        if (currentResultData) {
          let contentArray = null;
          if (currentResultData.data && currentResultData.data.outputs && currentResultData.data.outputs.content) {
            contentArray = currentResultData.data.outputs.content;
          } else if (currentResultData.content) {
            contentArray = currentResultData.content;
          }
          
          if (contentArray && contentArray[chapterIndex]) {
            // 更新对应章节的内容
            contentArray[chapterIndex].content = chapterContent;
            console.log(`[重新生成完成] currentResultData 中章节 ${chapterIndex + 1} 的内容已更新`);
            
            // 更新 Store 中的结果
            Store.setState({
              step4Result: currentResultData
            });
            
            // 无论当前是预览模式还是编辑模式，都更新预览显示，确保数据同步
            renderMarkdownPreview(currentResultData);
          } else {
            console.warn(`[重新生成警告] 无法找到章节 ${chapterIndex + 1} 在 contentArray 中，但文本框已更新`);
          }
        } else {
          console.warn('[重新生成警告] currentResultData 为空，但文本框已更新');
          // 即使没有 currentResultData，文本框也已经更新了，用户可以继续编辑
        }
        
        // 恢复按钮状态
        if (regenerateBtn) {
          regenerateBtn.disabled = false;
          regenerateBtn.textContent = '重新生成';
        }
        
        UI.showSuccess(`章节 "${batch.title}" 重新生成成功`);
        
      } catch (err) {
        console.error('重新生成章节失败:', err);
        
        // 恢复按钮和文本框状态 - 使用全局查找
        const regenerateBtn = document.querySelector(`button[data-chapter-index="${chapterIndex}"]`);
        const textarea = document.querySelector(`textarea[data-chapter-index="${chapterIndex}"]`);
        
        if (regenerateBtn) {
          regenerateBtn.disabled = false;
          regenerateBtn.textContent = '重新生成';
        }
        if (textarea) {
          textarea.disabled = false;
          // 如果之前有内容，恢复原内容；否则显示错误提示
          const state = Store.getState();
          if (state.step4Result) {
            try {
              const parsed = typeof state.step4Result === 'string' ? JSON.parse(state.step4Result) : state.step4Result;
              let contentArray = null;
              if (parsed.data && parsed.data.outputs && parsed.data.outputs.content) {
                contentArray = parsed.data.outputs.content;
              } else if (parsed.content) {
                contentArray = parsed.content;
              }
              if (contentArray && contentArray[chapterIndex]) {
                textarea.value = filterRedactedReasoning(contentArray[chapterIndex].content || '');
              } else {
                textarea.value = '';
              }
            } catch (e) {
              textarea.value = '';
            }
          } else {
            textarea.value = '';
          }
        }
        
        UI.showError(`重新生成失败: ${err.message}`);
      }
    }

    // 收集所有结果内容（只收集被勾选的内容）
    function collectResultContent() {
      const textareas = editMode.querySelectorAll('textarea');
      if (textareas.length === 0) return '';
      
      if (textareas.length === 1) {
        // 单个文本框
        return textareas[0].value;
      } else {
        // 多个文本框：构建数组结构，只收集被勾选的内容
        const contentArray = [];
        Array.from(textareas).forEach(textarea => {
          // 找到对应的勾选框（在同一 div 中）
          const parentDiv = textarea.closest('div');
          const checkbox = parentDiv?.querySelector('input[type="checkbox"]');
          
          // 只收集被勾选的内容
          if (!checkbox || checkbox.checked) {
            // 获取标题（从 label 中获取）
            const header = parentDiv?.querySelector('.flex.items-center');
            const label = header?.querySelector('label');
            const title = label?.textContent || '';
            
            contentArray.push({
              id: textarea.dataset.itemId || '',
              title: title,
              content: textarea.value
            });
          }
        });
        
        // 尝试从 state 中获取原始数据结构，保持格式一致
        const state = Store.getState();
        if (state.step4Result) {
          try {
            const original = typeof state.step4Result === 'string' ? JSON.parse(state.step4Result) : state.step4Result;
            if (original && original.data && original.data.outputs) {
              // 保持原始结构，只更新 content 数组
              original.data.outputs.content = contentArray;
              return JSON.stringify(original);
            }
          } catch (e) {
            // 如果解析失败，使用新结构
          }
        }
        
        // 如果没有原始结构，创建新的结构
        return JSON.stringify({
          data: {
            outputs: {
              content: contentArray
            }
          }
        });
      }
    }

    // 读取已有状态
    const state = Store.getState();
    if (state.step1Result) parseResult.value = Utils.getResultContent(state.step1Result);
    if (state.step2Result) outlineResult.value = Utils.getResultContent(state.step2Result);
    if (state.step3Result) companyResult.value = Utils.getResultContent(state.step3Result);
    if (state.step4UserReq) userReq.value = state.step4UserReq;
    if (state.step4Result) {
      renderResult(state.step4Result);
    }
    
    // 初始化：默认预览模式，保存按钮禁用
    saveBtn.disabled = true;
    
    // 编辑模式切换
    editBtn.addEventListener('click', () => {
      if (editMode.classList.contains('hidden')) {
        // 切换到编辑模式
        editMode.classList.remove('hidden');
        previewMode.classList.add('hidden');
        editBtn.textContent = '预览模式';
        // 启用保存按钮
        saveBtn.disabled = false;
      } else {
        // 切换到预览模式
        // 从编辑模式收集数据并更新预览
        const resultContent = collectResultContent();
        if (resultContent) {
          try {
            const parsed = typeof resultContent === 'string' ? JSON.parse(resultContent) : resultContent;
            currentResultData = parsed;
            renderMarkdownPreview(parsed);
          } catch (e) {
            currentResultData = resultContent;
            renderMarkdownPreview(resultContent);
          }
        }
        editMode.classList.add('hidden');
        previewMode.classList.remove('hidden');
        editBtn.textContent = '编辑模式';
        // 禁用保存按钮
        saveBtn.disabled = true;
      }
    });

    runBtn.addEventListener('click', async () => {
      try {
        if (!outlineResult.value.trim()) {
          UI.showError('请先完成步骤2并生成标书大纲');
          return;
        }
        // 允许公司资料为空，但提示
        if (!companyResult.value.trim()) {
          if (!confirm('未读取到公司资料，继续执行？')) return;
        }
        
        const apiKey = API.DIFY_CONFIG.apiKeys.step4;
        
        // 禁用提交按钮，显示进度
        runBtn.disabled = true;
        runBtn.textContent = '提交中...';
        editBtn.disabled = true;
        nextBtn.disabled = true;
        
        // 确保预览模式可见，用于显示流式输出
        previewMode.classList.remove('hidden');
        editMode.classList.add('hidden');
        
        // 检查是否有未完成的批次
        const progressKey = BatchSubmit.getBatchProgressKey(
          outlineResult.value.trim(),
          parseResult.value.trim(),
          companyResult.value.trim(),
          userReq.value.trim()
        );
        const progress = BatchSubmit.getBatchProgress(progressKey);
        const hasUnfinishedProgress = progress && progress.completedBatches && progress.completedBatches.length > 0;
        
        // 如果有未完成的批次，询问是否继续
        let shouldResume = true;
        if (hasUnfinishedProgress) {
          const completed = progress.completedBatches.length;
          const total = progress.totalBatches;
          shouldResume = confirm(`检测到未完成的批次（已完成 ${completed}/${total}），是否从第 ${completed + 1} 个批次继续提交？\n\n点击"确定"继续，点击"取消"重新开始。`);
        }
        
        // 使用分批提交（支持断点续传和流式输出）
        const mergedResult = await BatchSubmit.batchSubmitTender({
          outline: outlineResult.value.trim(),
          parseResult: parseResult.value.trim(),
          companyResult: companyResult.value.trim(),
          userReq: userReq.value.trim(),
          apiKey: apiKey,
          resume: shouldResume,
          onProgress: (current, total, batchTitle) => {
            // 更新按钮文本显示进度
            runBtn.textContent = `提交中... (${current}/${total}) ${batchTitle}`;
          },
          onBatchComplete: (batchIndex, batchTitle, batchContent, allBatchesContent) => {
            // 每个批次完成后立即显示
            try {
              console.log('批次完成:', { batchIndex, batchTitle, allBatchesCount: allBatchesContent.length });
              
              // 过滤掉 <think> 标签
              const filteredBatchesContent = allBatchesContent.map(item => ({
                ...item,
                content: filterRedactedReasoning(item.content || '')
              }));
              
              const tempResult = {
                data: {
                  outputs: {
                    content: filteredBatchesContent
                  }
                }
              };
              
              // 确保预览模式可见
              if (previewMode) {
                previewMode.classList.remove('hidden');
              }
              if (editMode) {
                editMode.classList.add('hidden');
              }
              
              // 更新预览，显示所有已完成的批次
              if (markdownPreview) {
                renderMarkdownPreview(tempResult);
                // 滚动到底部以显示最新内容
                markdownPreview.scrollTop = markdownPreview.scrollHeight;
              } else {
                console.error('markdownPreview 元素不存在');
              }
              
              // 同时更新 currentResultData，以便后续使用
              currentResultData = tempResult;
            } catch (e) {
              console.error('更新批次完成预览失败:', e, e.stack);
            }
          },
          onError: (error) => {
            console.error('分批提交错误:', error);
            // 出错时不清除进度，以便下次继续
          }
        });
        
        // 恢复按钮状态
        runBtn.disabled = false;
        runBtn.textContent = '提交';
        editBtn.disabled = false;
        nextBtn.disabled = false;
        
        // 过滤掉 <think> 标签后再渲染最终结果
        let filteredResult = mergedResult;
        if (mergedResult && mergedResult.data && mergedResult.data.outputs && mergedResult.data.outputs.content) {
          filteredResult = {
            ...mergedResult,
            data: {
              ...mergedResult.data,
              outputs: {
                ...mergedResult.data.outputs,
                content: mergedResult.data.outputs.content.map(item => ({
                  ...item,
                  content: filterRedactedReasoning(item.content || '')
                }))
              }
            }
          };
        } else if (typeof mergedResult === 'string') {
          filteredResult = filterRedactedReasoning(mergedResult);
        }
        
        // 使用过滤后的响应数据渲染结果
        renderResult(filteredResult);
        
        // 执行后切换到预览模式
        editMode.classList.add('hidden');
        previewMode.classList.remove('hidden');
        editBtn.textContent = '编辑模式';
        saveBtn.disabled = true;
        
        // 保存过滤后的响应数据
        const result = filteredResult;

        // 保存所有修改的内容
        Store.setState({
          step1Result: parseResult.value.trim(), // 保存修改后的解析结果
          step2Result: outlineResult.value.trim(), // 保存修改后的大纲
          step3Result: companyResult.value.trim(), // 保存修改后的公司资料
          step4Result: result, // 保存合并后的结果
          step4UserReq: userReq.value.trim(),
        });
      } catch (err) {
        // 出错时也要恢复按钮状态
        runBtn.disabled = false;
        runBtn.textContent = '提交';
        editBtn.disabled = false;
        nextBtn.disabled = false;
        UI.showError(err.message);
      }
    });

    saveBtn.addEventListener('click', () => {
      // 收集所有结果内容
      const resultContent = collectResultContent();
      
      // 保存所有修改的内容
      Store.setState({
        step1Result: parseResult.value.trim(), // 保存修改后的解析结果
        step2Result: outlineResult.value.trim(), // 保存修改后的大纲
        step3Result: companyResult.value.trim(), // 保存修改后的公司资料
        step4Result: resultContent, // 保存收集的结果内容
        step4UserReq: userReq.value.trim(),
      });
      window.location.href = 'step5-compliance.html';
    });

    nextBtn.addEventListener('click', () => {
      window.location.href = 'step5-compliance.html';
    });
  </script>
</body>
</html>

